// Code generated by protoc-gen-sxf. DO NOT EDIT.
// source: example.proto

package example

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RequestServiceDebugCmd
func (in *RequestServiceDebugCmd) Clone() *RequestServiceDebugCmd {
	if in == nil {
		return nil
	}
	out := &RequestServiceDebugCmd{}
	out.Cmd = in.Cmd
	out.Param = in.Param
	out.Groups = CloneArrayint32(in.Groups)
	out.Unit = CloneArraystring(in.Unit)
	out.Beasts = CloneArrayint32(in.Beasts)
	out.Commanders = CloneArraybyte(in.Commanders)
	out.Apple = in.GetApple().Clone()
	out.Tem = CloneMapStringInt32(in.Tem)
	out.Addr = CloneMapStringInt32(in.Addr)
	out.AddrEntry = CloneMapStringApplesServerin(in.AddrEntry)
	out.AddrEntry2 = CloneMapStringApplesServerin(in.AddrEntry2)
	return out
}

// ApplesServerin
func (in *ApplesServerin) Clone() *ApplesServerin {
	if in == nil {
		return nil
	}
	out := &ApplesServerin{}
	out.Id = in.Id
	out.Name = in.Name
	out.Student = CloneArrayint32(in.Student)
	out.Teacher = CloneArraystring(in.Teacher)
	out.Bb = in.GetBb().Clone()
	return out
}

// Binary
func (in *Binary) Clone() *Binary {
	if in == nil {
		return nil
	}
	out := &Binary{}
	out.Id = CloneArraystring(in.Id)
	out.Aa = in.GetAa().Clone()
	return out
}

func CloneArrayint32(arr []int32) []int32 {
	if arr == nil {
		return nil
	}
	a := make([]int32, len(arr), cap(arr))
	copy(a, arr)
	return a
}

func CloneArraystring(arr []string) []string {
	if arr == nil {
		return nil
	}
	a := make([]string, len(arr), cap(arr))
	copy(a, arr)
	return a
}

func CloneArraybyte(arr [][]byte) [][]byte {
	if arr == nil {
		return nil
	}
	a := make([][]byte, len(arr), cap(arr))
	copy(a, arr)
	return a
}

func CloneMapStringInt32(m map[string]int32) map[string]int32 {
	if m == nil {
		return nil
	}
	a := make(map[string]int32, len(m))
	for k, v := range m {
		a[k] = v
	}
	return a
}

func CloneMapStringApplesServerin(m map[string]*ApplesServerin) map[string]*ApplesServerin {
	if m == nil {
		return nil
	}
	a := make(map[string]*ApplesServerin, len(m))
	for k, v := range m {
		a[k] = v.Clone()
	}
	return a
}
