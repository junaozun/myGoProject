现在我们完成了一个基于 tcp 协议的 client/server 通讯服务。我们之前说到了，transport 的核心能力是提供 client 和 server 的底层通信实现。上面的代码已经实现了 client 和 server 互发消息，
是不是已经达到我们的目标了呢？慢，我们之前的目标可是高性能，假如深入思考一下，它其实存在以下几个问题：

1、server 对请求的读写处理是同步的，假如这里同时有两个请求 A、B，只有等请求 A 的读写操作完全完成时，才能进行请求 B 的读写操作，这无疑产生了很严重的等待时间浪费。

2、server 每次监听到一个请求都会创建一个连接 conn，用 conn 去进行数据的读写，读写完成之后连接 conn 会被关闭，假如同时有成千上万个请求需要处理，每次请求都需要创建和销毁 conn 对象，会造成很大的性能损耗。

3、server 和 client 每次处理消息时，需要用到一块内存 buffer 用来进行消息读取，这一块内存也会存在频繁创建和销毁问题。

4、假如 client 或者 server 需要发送的数据包过大，tcp 协议会进行拆包，即把大的数据包拆成多份发送。假如 client 需要发送的数据包过小，tcp 协议底层会进行粘包，即多个数据包合并发送。这种情况下，上面的代码是无法支持的，
会出现 client 或者 server 读取到的数据包不完整。

5、client 每次发送**一个数据包都需要创建一个连接 conn，假设请求量过大，可能会出现单机连接数不够用的情况。